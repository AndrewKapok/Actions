name: Cloudflare Tunnel Test

on:
  workflow_dispatch:
    inputs:
      local_port:
        description: '本地服务端口'
        required: true
        default: '11434'
      timeout_minutes:
        description: '服务运行时长（分钟）'
        required: true
        default: '30'

jobs:
  cloudflare-tunnel-test:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ inputs.timeout_minutes || 30 }}
    
    steps:
      # 服务准备阶段
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置 Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: 安装依赖
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: 创建 HTTP 服务器
        run: |
          # 创建测试页面
          mkdir -p server
          cat > server/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
              <title>Cloudflare Tunnel Test</title>
              <style>
                  body { font-family: Arial, sans-serif; margin: 40px; }
                  h1 { color: #333; }
                  .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
                  .success { background-color: #d4edda; color: #155724; }
                  .info { background-color: #d1ecf1; color: #0c5460; }
              </style>
          </head>
          <body>
              <h1>Cloudflare Tunnel Test Server</h1>
              <div class="status success">服务状态: 运行中</div>
              <div class="status info">本地端口: ${{ inputs.local_port }}</div>
              <div class="status info">启动时间: $(date)</div>
              <p>此页面用于验证 Cloudflare Tunnel 是否正常工作。</p>
          </body>
          </html>
          EOF
          
          # 启动 HTTP 服务器
          cd server && python -m http.server ${{ inputs.local_port }} &
          SERVER_PID=$!
          echo $SERVER_PID > ../server.pid
          
          # 等待服务启动
          sleep 5
          
          # 检查服务是否正常启动
          if curl -s http://localhost:${{ inputs.local_port }} > /dev/null; then
              echo "HTTP 服务器启动成功"
          else
              echo "HTTP 服务器启动失败"
              exit 1
          fi

      # 隧道配置阶段
      - name: 安装 Cloudflare Tunnel
        run: |
          # 检查是否已安装
          if command -v cloudflared &> /dev/null; then
              echo "cloudflared 已安装"
          else
              echo "安装 cloudflared..."
              wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -O /tmp/cloudflared
              sudo chmod +x /tmp/cloudflared
              sudo mv /tmp/cloudflared /usr/local/bin/cloudflared
              if cloudflared --version; then
                  echo "cloudflared 安装成功"
              else
                  echo "cloudflared 安装失败"
                  exit 1
              fi
          fi

      - name: 启动隧道
        id: start-tunnel
        run: |
          if [ -n "${{ secrets.CF_TOKEN }}" ]; then
              # 使用持久化隧道
              echo "使用持久化隧道模式"
              
              # 创建隧道配置目录
              mkdir -p ~/.cloudflared
              
              # 设置环境变量
              export CF_API_TOKEN=${{ secrets.CF_TOKEN }}
              
              # 创建隧道
              TUNNEL_NAME="github-actions-tunnel-$(date +%s)"
              TUNNEL_OUTPUT=$(cloudflared tunnel create $TUNNEL_NAME 2>&1)
              echo "隧道创建输出: $TUNNEL_OUTPUT"
              
              # 提取隧道 ID
              TUNNEL_ID=$(echo "$TUNNEL_OUTPUT" | grep -oP 'Created tunnel .* with id \K[^\s]+')
              if [ -z "$TUNNEL_ID" ]; then
                  echo "无法创建持久化隧道，尝试使用 Quick Tunnel"
                  # 回退到 Quick Tunnel
                  cloudflared tunnel --url http://localhost:${{ inputs.local_port }} --name quick-tunnel > tunnel.log 2>&1 &
                  TUNNEL_PID=$!
                  echo $TUNNEL_PID > tunnel.pid
                  
                  # 等待隧道启动并获取 URL
                  sleep 10
                  TUNNEL_URL=$(grep -oP 'https://[^\s]+trycloudflare.com' tunnel.log | tail -1)
              else
                  echo "隧道 ID: $TUNNEL_ID"
                  
                  # 创建配置文件
                  cat > ~/.cloudflared/config.yml << EOF
          tunnel: $TUNNEL_ID
          credentials-file: ~/.cloudflared/$TUNNEL_ID.json
          ingress:
            - hostname: *
              service: http://localhost:${{ inputs.local_port }}
            - service: http_status:404
          EOF
                  
                  # 启动隧道
                  cloudflared tunnel --config ~/.cloudflared/config.yml run > tunnel.log 2>&1 &
                  TUNNEL_PID=$!
                  echo $TUNNEL_PID > tunnel.pid
                  echo $TUNNEL_ID > tunnel_id.txt
                  
                  # 等待隧道启动并获取 URL
                  sleep 10
                  TUNNEL_URL=$(cloudflared tunnel info $TUNNEL_ID 2>&1 | grep -oP 'https://[^\s]+trycloudflare.com')
              fi
          else
              # 使用 Quick Tunnel
              echo "使用 Quick Tunnel 模式"
              cloudflared tunnel --url http://localhost:${{ inputs.local_port }} --name quick-tunnel > tunnel.log 2>&1 &
              TUNNEL_PID=$!
              echo $TUNNEL_PID > tunnel.pid
              
              # 等待隧道启动并获取 URL
              sleep 10
              TUNNEL_URL=$(grep -oP 'https://[^\s]+trycloudflare.com' tunnel.log | tail -1)
          fi
          
          # 保存隧道 URL
          if [ -n "$TUNNEL_URL" ]; then
              echo "隧道 URL: $TUNNEL_URL"
              echo $TUNNEL_URL > tunnel_url.txt
              echo "tunnel_url=$TUNNEL_URL" >> $GITHUB_OUTPUT
          else
              echo "无法获取隧道 URL"
              exit 1
          fi

      # 服务管理阶段
      - name: 显示服务信息
        run: |
          echo "========================================"
          echo "服务信息"
          echo "========================================"
          echo "本地地址: http://localhost:${{ inputs.local_port }}"
          echo "公网地址: $(cat tunnel_url.txt)"
          echo "========================================"

      - name: 保持服务运行
        run: |
          TIMEOUT_SECONDS=$(( ${{ inputs.timeout_minutes }} * 60 ))
          START_TIME=$(date +%s)
          END_TIME=$(( START_TIME + TIMEOUT_SECONDS ))
          
          echo "服务将运行 ${{ inputs.timeout_minutes }} 分钟，直到 $(date -d @$END_TIME)"
          
          while [ $(date +%s) -lt $END_TIME ]; do
              echo "$(date): 服务运行中..."
              
              # 检查本地服务
              if curl -s http://localhost:${{ inputs.local_port }} > /dev/null; then
                  echo "$(date): 本地服务正常"
              else
                  echo "$(date): 本地服务异常"
              fi
              
              # 检查隧道连接
              if curl -s $(cat tunnel_url.txt) > /dev/null; then
                  echo "$(date): 隧道连接正常"
              else
                  echo "$(date): 隧道连接异常"
              fi
              
              # 等待 60 秒
              sleep 60
          done

      - name: 测试连接
        run: |
          echo "测试本地服务连接..."
          if curl -s http://localhost:${{ inputs.local_port }} > /dev/null; then
              echo "本地服务连接成功"
          else
              echo "本地服务连接失败"
          fi
          
          echo "测试隧道连接..."
          if curl -s $(cat tunnel_url.txt) > /dev/null; then
              echo "隧道连接成功"
          else
              echo "隧道连接失败"
          fi

      - name: 上传日志
        uses: actions/upload-artifact@v4
        with:
          name: tunnel-logs
          path: |
            tunnel.log
            tunnel_url.txt

      - name: 清理资源
        if: always()
        run: |
          echo "清理资源..."
          
          # 停止 HTTP 服务器
          if [ -f server.pid ]; then
              SERVER_PID=$(cat server.pid)
              kill $SERVER_PID 2>/dev/null || true
              echo "HTTP 服务器已停止"
          fi
          
          # 停止隧道
          if [ -f tunnel.pid ]; then
              TUNNEL_PID=$(cat tunnel.pid)
              kill $TUNNEL_PID 2>/dev/null || true
              echo "隧道已停止"
          fi
          
          # 删除临时隧道
          if [ -f tunnel_id.txt ]; then
              TUNNEL_ID=$(cat tunnel_id.txt)
              export CF_API_TOKEN=${{ secrets.CF_TOKEN }}
              cloudflared tunnel delete -f $TUNNEL_ID 2>/dev/null || true
              echo "临时隧道已删除"
          fi
          
          echo "资源清理完成"
